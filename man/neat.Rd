% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neat.R
\name{neat}
\alias{neat}
\title{NeuralEvolution of Augmenting Topologies}
\usage{
neat(fn, starting_pop, max_generations = 100, solution_tolerance = 0.001,
  n_stagnate = 15, print_level = 1, kill_percentage = 0.2,
  number_for_kill = 5, selection.pressure = 2, em_rate = 0.25,
  wm_rate = 0.9, lm_rate = 0.4, nm_rate = 0.04, wm_power = 2.5,
  wm_limit = 10, threshold = 6, c1 = 2, c2 = 2, c3 = 1)
}
\arguments{
\item{fn}{Function with a single neural network as input and a numeric single fitness value as output}

\item{starting_pop}{List of neural networks}

\item{max_generations}{Numerical value for the hard maximum number of generations}

\item{solution_tolerance}{Numerical value for solution tolerance, two numbers differing this much
will be considered equal}

\item{n_stagnate}{Numerical indicating the number of generations witouth any improvement to cause an early stop}

\item{print_level}{Numerical value of the printing level: 0 = none, 1 = minimal, 2 = full}

\item{kill_percentage}{Numerical [0,1] indicating the fraction of individuals that will be excluded
from the mating proccess.}

\item{number_for_kill}{Numerical value for minimal population size for killing}

\item{selection.pressure}{Numerical value used as exponent when evaluating the shared fitness,
 higher numbers will make more elite populations reproduce more often

TODO:
  melhorar as mutacoes, ver codigo matlab, mas a ideia e garantir que a mutacao ocorra caso seja sorteada
  rever codigo de crossover
  melhorar output da funcao neat
  criar funcao de pos processamento}

\item{em_rate, wm_rate, lm_rate, nm_rate}{Numerical in [0,1] of the probability of mutations
\itemize{
 \item em_rate = enable mutation
 \item wm_rate = node mutation
 \item lm_rate = link mutation
 \item nm_rate = node mutation
}}

\item{wm_power}{Numeric indicating the magnitude of the weight mutation. The perturbation will be sampled
from an unifor distribution [-wm_power, wm_power]}

\item{wm_limit}{Numeric cap for the weight of a mutated network}

\item{threshold}{Numerical trheshold of divergence of species}

\item{c1, c2, c3}{Numerical weighting constants for the species filter:
\itemize{
 \item c1 = weight of excess genes
 \item c2 = weight of disjoint genes
 \item c3 = weight of average weight differences
}}
}
\description{
NeuralEvolution of Augmenting Topologies
}
\examples{
fn <- function(nn){
 xor_inputs = rbind(c(0,0),
                    c(1,0),
                    c(0,1),
                    c(1,1))
 xor_outputs = c(0,1,1,0)
 nn_outputs <- apply(xor_inputs, 1, activate, nn = nn, act_fun = function(x) sigmoid(x, 4.9))
 (4 - sum(abs(xor_outputs - nn_outputs)))^2
}
npop = 30
max_generations = 20
starting_pop <- populate.nn(npop, 2, 1)
optimal_pop <- neat(fn, starting_pop, max_generations)


\dontrun{
 # the following example should converge to the optima
 npop = 150
 max_generations = 100
 starting_pop <- populate.nn(npop, 2, 1)
 optimal_pop <- neat(fn, starting_pop, max_generations)
}
}
